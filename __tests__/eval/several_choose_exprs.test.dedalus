% LineName, StationName, OpeningYear, Depth
metro("red", "Bulvar Rokossovskogo", 1990, -8)@1;
metro("red", "Cherkizovskaya", 1990, -9)@1;
metro("red", "Preobrazhenskaya Ploshchad", 1965, -8)@1;
metro("red", "Sokolniki", 1935, -9)@1;
metro("green", "Khovrino", 2017, -14)@1;
metro("green", "Belomorskaya", 2018, -25)@1;
metro("aqua", "Kuntsevskaya", 1965, 0)@1;
metro("aqua", "Kutuzovskaya", 1958, 0)@1;
metro("aqua", "Studencheskaya", 1958, 0)@1;

rule1(Line, Station, Year) :-
  metro(Line, Station, Year, _Depth),
  % should be equivalent to
  % choose((Line), (Station, Year))
  choose((Line), (Year)),
  choose((Year), (Station));

rule1_count(Line, Year, count<Station>) :-
  rule1(Line, Station, Year);

rule1_correct_selection_count :-
  rule1_count("red", 1990, 1),
  rule1_count("green", 1958, 1);

rule2(Line, Station, Year) :-
  metro(Line, Station, Year, _Depth),
  % should be equivalent to
  % choose((Line), (Station, Year))
  choose((Line), (Year)),

% rule2(Line, Station, Year) :-
%   metro(Line, Station, Year, _Depth),
%   % should be equivalent to
%   choose((Line), (Station, Year));

% rule2 :-
%   metro(Line2, Station2, Year2, _Depth),
%   choose((Line2, Year2), (Station2)),


% What I want to test?
%
% Several choose statements in one clause.
%
% Check that if we make choices that exclude each other
%
%
% Hm. I want to run non-deterministic clauses several times
% and check that it always acts correctly
%

% Clauses in this test are not deterministic because they include
% choose expression. It means that they may produce different result
% for exactly same input. That's why it would be reasonable to run it several times
% just in case

times_to_run(10)@1;

current_test_num(N)@next :- times_to_run(N);
current_test_num(N)@next :-
  N =/= 0,
  current_test_num(N1)
  successor(N, N1);

% test_passed :-
%   % all 
%   current_test_num(0),
%   times_to_run(N),

