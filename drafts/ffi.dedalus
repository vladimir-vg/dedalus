% Dedalus does not and will not have functions as part of the language.
% However, it can send and receive messages.
% it might be reasonable to have a convention for calling functions.
%
% Functions will take collections of facts of several types, as piece of memory
% work with it, produce more facts, which asynchronously would arrive to the calling Dedalus node.
%
% It would be convenient to allow several tables to be inputs and outputs. How we gonna do that?
% It would be correct to use as little special interpretation for tables as possible.
%
% We could use pair FuncName, Timestamp as a reference id for a function call

% What func call input really is? It is just set of tuples grouped together.
% We can do following:
%
% * treat fun_call_input(FuncName, T, TableName)@async in special way. Make sure that all tables
%   among TableName arrive atomically to receiver.
% * All input tables are computed at same timestamp as fun_call_input(...)@async
%
% That's the only assumptions. Everything else looks like usual Dedalus code.
% If there is no implementation for this function call, it would never get response.
% If there is no support for function calls, no response either. Neat.

% first we obtain a timestamp to be used as an identifier
fun_call_id(Name, T)@async :-
  fun_call_request(Name)@T;


% we hope that tuples fun_call_input
% and input_table1 won't get lost,

fun_call_input(FuncName, T, TableName)@async :-
  fun_call_id(FuncName, T);

input_table1(FuncName, T, Arg1, Arg2)@async :-
  fun_call(FuncName, T),
  table1(Arg1, Arg2);

% If we communicate with homogeneous nodes, then it is cool, we know exactly
% what kind of messages we may receive and what types fields have.
% However, what if we want to communicate with nodes that implemented differently?
%
% It would be useful to express somehow what kind of facts may appear
% on this node, delivered from outside. Some kind of way
% to show names of the tables, types of the arguments.


% we can have something like this?
% we just show that facts like these may arrive somehow.
% although it would never produce any atoms, since
% it has false in its body. Yet, it has enough
% information to infer type.
%
% 
% string(), symbol() and integer() are range-unrestriced
% just like successor.
%
% We are expected to infer all types in compile time.
% thus these string(), symbol() and integer() rules
% don't really participate in deduction.
fact_from_outside(Arg1, Arg2, Arg3)@async :-
  false,
  string(Arg1),
  symbol(Arg2),
  integer(Arg3);

% this way we could declare what kind of facts
% we may receive from outside. This way analyzer would have
% full information.
output_table1(FuncName, T, Arg1, Arg2)@async :-
  false,
  symbol(FuncName),
  integer(T),
  string(Arg1),
  symbol(Arg2);
