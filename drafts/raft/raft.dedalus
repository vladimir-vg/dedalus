node(0, "/ip4/127.0.0.1/udp/5000")@0.
node(1, "/ip4/127.0.0.1/udp/5001")@0.
node(2, "/ip4/127.0.0.1/udp/5002")@0.
node(3, "/ip4/127.0.0.1/udp/5003")@0.
node(4, "/ip4/127.0.0.1/udp/5004")@0.
node(NodeId, Addr)@next :- node(NodeId, Addr).

% initially every node starts as a follower with term=0
% TODO: really inconvenient to hardcode node_id here.
% better to find a way to read environment variables somehow (readonly)
this_node(4, 0, follower)@0.



rt:start_timer(#timers, ElectionDurationMs, election, T)@async :-
  % TODO: make a request to runtime to get random number, between 150 and 300
  ElectionDurationMs = 150,
  this_node(_NodeId, _Term, follower)@T,
  notin running_timer(election, _).
rt:start_timer(#timers, ElectionDurationMs, election, T)@async :-
  ElectionDurationMs = 150,
  this_node(_NodeId, _Term, candidate)@T,
  notin running_timer(election, _).

running_timer(Tag, T)@next :-
  running_timer(Tag, T),
  notin rt:timer_fired(Tag, T),
  notin rt:timer_cancelled(Tag, T).
running_timer(election, T) :-
  rt:timer_started(election, T).



this_node(NodeId, Term, follower)@next :-
  higher_term_vote_request(_CandidateId, Term),
  this_node(NodeId, _PrevTerm, _State).

this_node(NodeId, Term, candidate)@next :-
  notin higher_term_vote_request(_CandidateId, _Term),
  rt:timer_fired(election, _),
  this_node(NodeId, PrevTerm, follower),
  successor(PrevTerm, Term).

this_node(NodeId, Term, follower)@next :-
  notin higher_term_vote_request(_CandidateId, _Term),
  notin rt:timer_fired(election, _),
  this_node(NodeId, Term, follower).

% voted_for(NodeId) :-
%   rt:timer_fired(election, _)

% vote requests are sent immediately
% on the next tick after getting status
% of a candidate

vote_requests_sent@next :- vote_requests_sent.
vote_requests_sent@next :- this_node(NodeId, Term, candidate).

% This tuple will be sent only once per term,
% on the first tick as a candidate.
% This tuple corresponds to RequestVote in Raft paper
request_vote(#VoterAddr, CandidateId, CandidateTerm)@async :-
  node(VoterId, VoterAddr),
  this_node(CandidateId, CandidateTerm, candidate),
  VoterId =/= CandidateId,
  notin vote_requests_sent.



% We may receive several vote requests on single tick.
% If we have equality eligible candidates,
% then we should choose one non-deterministically
% using choose() expression.
%
% Also, if term of the candidate is higher than current term,
% we should transition to follower.
%
% What if start election timer fired exactly on the same tick
% as request_vote arrived? We should prioritise ourself,
% but only if term numbers are equal.
%
% Algorithm:
% 1) Select vote requests with max term (could be one or more)
% 2) If max term is higher than current term, then vote for it, transition to follower
% 3) If max term is equal to current term, and current term is follower then vote if haven't voted before.
% 4) Otherwise, reject vote.

% in case if election timer trigger event
% arrived at the same tick with request_vote
% we need to consider both options.
%
% For consistency, let's construct request_vote tuple,
% as if we tried to vote for ourselves.
% It is easier to compare candidates' terms this way.
request_vote(VoterAddr, CandidateId, NextTerm) :-
  this_node(CandidateId, PrevTerm, follower),
  node(CandidateId, CandidateAddr),
  VoterAddr = CandidateAddr,
  rt:timer_fired(election, _),
  successor(PrevTerm, NextTerm).

request_vote_max_term(max<CandidateTerm>) :-
  request_vote(_VoterAddr, _CandidateId, CandidateTerm).



% Only one among these three tuples must be present at the same time:
failure:vote_request_choices_not_disjoint@async :-
  higher_term_vote_request(_, _),
  same_term_remote_vote_request(_, _).
failure:vote_request_choices_not_disjoint@async :-
  higher_term_vote_request(_, _),
  same_term_self_vote_request(_, _).
failure:vote_request_choices_not_disjoint@async :-
  same_term_self_vote_request(_, _),
  same_term_remote_vote_request(_, _).

higher_term_vote_request(CandidateId, MaxTerm) :-
  this_node(_VoterId, VoterTerm, _State),
  request_vote_max_term(MaxTerm)
  request_vote(_OurAddr, CandidateId, MaxTerm),
  VoterTerm < MaxTerm,
  choose((), (CandidateId)).

same_term_remote_vote_request(CandidateId, CandidateTerm) :-
  CandidateId =/= VoterId,
  CandidateTerm = VoterTerm,
  this_node(VoterId, VoterTerm, follower),
  request_vote_max_term(CandidateTerm)
  request_vote(_OurAddr, CandidateId, CandidateTerm),
  notin voted_for(_, CandidateTerm),
  choose((), (CandidateId)).

same_term_self_vote_request(CandidateId, CandidateTerm) :-
  CandidateId = VoterId,
  CandidateTerm = VoterTerm,
  this_node(VoterId, VoterTerm, follower),
  request_vote_max_term(CandidateTerm)
  request_vote(_OurAddr, CandidateId, CandidateTerm),
  notin voted_for(_, CandidateTerm),
  choose((), (CandidateId)).



voted_for(CandidateId, ElectionTerm)@next :-
  same_term_self_vote_request(CandidateId, ElectionTerm),
  notin higher_term_vote_request(_, _),
  notin same_term_remote_vote_request(_, _),
  notin voted_for(_, ElectionTerm).
voted_for(CandidateId, ElectionTerm)@next :-
  same_term_remote_vote_request(CandidateId, ElectionTerm),
  notin same_term_self_vote_request(_, _),
  notin higher_term_vote_request(_, _),
  notin voted_for(_, ElectionTerm).
voted_for(CandidateId, ElectionTerm)@next :-
  higher_term_vote_request(CandidateId, ElectionTerm),
  notin higher_term_vote_request(_, _),
  notin same_term_remote_vote_request(_, _).
voted_for(CandidateId, ElectionTerm)@next :-
  % keep voted_for fact only during its election term
  this_node(_NodeId, ElectionTerm, _State),
  voted_for(CandidateId, ElectionTerm),
  notin same_term_vote_request(_),
  notin higher_term_vote_request(_),
  notin same_term_self_vote_request(_).



vote_response(#CandidateAddr, VoterId, VoterTerm, Decision)@async :-
  request_vote(_OurAddr, CandidateId, CandidateTerm),
  node(CandidateAddr, CandidateId),
  this_node(VoterId, VoterTerm, _State),
  % check that this is not the request vote tuple that
  % we constructed artificially for consistency
  CandidateId =/= VoterId,
  voted_for(CandidateId, CandidateTerm),
  Decision = true.
vote_response(#CandidateAddr, VoterId, VoterTerm, Decision)@async :-
  request_vote(_OurAddr, CandidateId, CandidateTerm),
  node(CandidateAddr, CandidateId),
  this_node(VoterId, _Term, _State),
  CandidateId =/= VoterId,
  notin voted_for(CandidateId, CandidateTerm),
  Decision = false.
  

